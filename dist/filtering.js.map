{"version":3,"file":"filtering.js","mappings":";;;;;;;;;AAQA;AACA;AACA;AAIA;AACA;AAAA;AAHA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA","sources":["webpack://extensions-api-sdk/./Samples-Typescript/Filtering/filtering.ts"],"sourcesContent":["import {\r\n    CategoricalFilter,\r\n    Filter,\r\n    RangeFilter,\r\n    RelativeDateFilter,\r\n    TableauEvent\r\n} from '@tableau/extensions-api-types';\r\n\r\n// Wrap everything in an anonymous function to avoid polluting the global namespace\r\n(async () => {\r\n    class Filtering {\r\n\r\n        private unregisterHandlerFunctions = [];\r\n\r\n        // Avoid globals\r\n        constructor(private _$: JQueryStatic) { }\r\n\r\n        public async initialize() {\r\n            console.log('Waiting for DOM ready');\r\n            await this._$.ready;\r\n\r\n            console.log('Initializing extension API');\r\n            await tableau.extensions.initializeAsync();\r\n\r\n            // Fetch Filters\r\n            this.fetchFilters();\r\n\r\n            // Add button handlers for clearing filters.\r\n            this._$('#clear').click(() => this.clearAllFilters());\r\n        }\r\n\r\n        private async fetchFilters() {\r\n            // While performing async task, show loading message to user.\r\n            this._$('#loading').addClass('show');\r\n\r\n            // Since filter info is attached to the worksheet, we will perform\r\n            // one async call per worksheet to get every filter used in this\r\n            // dashboard.  This demonstrates the use of Promise.all to combine\r\n            // promises together and wait for each of them to resolve.\r\n            const filterFetchPromises: Array<Promise<Filter[]>> = [];\r\n\r\n            // List of all filters in a dashboard.\r\n            const dashboardfilters: Filter[] = [];\r\n\r\n            // To get filter info, first get the dashboard.\r\n            const dashboard = tableau.extensions.dashboardContent.dashboard;\r\n\r\n            // Whenever we restore the filters table, remove all save handling functions,\r\n            // since we add them back later in fetchFilters()\r\n            this.unregisterHandlerFunctions.forEach(function(unregisterHandlerFunction) {\r\n                unregisterHandlerFunction();\r\n            });\r\n\r\n            this.unregisterHandlerFunctions = [];\r\n            // Then loop through each worksheet and get its filters, save promise for later.\r\n            dashboard.worksheets.forEach(function(worksheet) {\r\n                filterFetchPromises.push(worksheet.getFiltersAsync());\r\n\r\n                // Add filter event to each worksheet.  AddEventListener returns a function that will\r\n                // remove the event listener when called.\r\n                const unregisterHandlerFunction =\r\n                    worksheet.addEventListener(\r\n                        tableau.TableauEventType.FilterChanged, (event) => this.filterChangedHandler(event));\r\n                this.unregisterHandlerFunctions.push(unregisterHandlerFunction);\r\n            }, this);\r\n\r\n            // Now, we call every filter fetch promise, and wait for all the results\r\n            // to finish before displaying the results to the user.\r\n            const fetchResults = await Promise.all(filterFetchPromises);\r\n            fetchResults.forEach(function(filtersForWorksheet) {\r\n                filtersForWorksheet.forEach(function(filter) {\r\n                    dashboardfilters.push(filter);\r\n                });\r\n            });\r\n\r\n            this.buildFiltersTable(dashboardfilters);\r\n        }\r\n\r\n        // This is a handling function that is called anytime a filter is changed in Tableau.\r\n        private filterChangedHandler(filterEvent: TableauEvent) {\r\n            // Just reconstruct the filters table whenever a filter changes.\r\n            // This could be optimized to add/remove only the different filters.\r\n            this.fetchFilters();\r\n        }\r\n\r\n        // Constructs UI that displays all the dataSources in this dashboard\r\n        // given a mapping from dataSourceId to dataSource objects.\r\n        private buildFiltersTable(filters: Filter[]) {\r\n            // Clear the table first.\r\n            this._$('#filtersTable > tbody tr').remove();\r\n            const filtersTable = this._$('#filtersTable > tbody')[0];\r\n\r\n            filters.forEach(function(filter) {\r\n                // @ts-ignore\r\n                const newRow = filtersTable.insertRow(filtersTable.rows.length);\r\n                const nameCell = newRow.insertCell(0);\r\n                const worksheetCell = newRow.insertCell(1);\r\n                const typeCell = newRow.insertCell(2);\r\n                const valuesCell = newRow.insertCell(3);\r\n\r\n                const valueStr = this.getFilterValues(filter);\r\n\r\n                nameCell.innerHTML = filter.fieldName;\r\n                worksheetCell.innerHTML = filter.worksheetName;\r\n                typeCell.innerHTML = filter.filterType;\r\n                valuesCell.innerHTML = valueStr;\r\n            }, this);\r\n\r\n            this.updateUIState(Object.keys(filters).length > 0);\r\n        }\r\n\r\n        // This returns a string representation of the values a filter is set to.\r\n        // Depending on the type of filter, this string will take a different form.\r\n        private getFilterValues(filter: Filter) {\r\n            let filterValues = '';\r\n\r\n            switch (filter.filterType) {\r\n                case tableau.FilterType.Categorical:\r\n                    const categoricalFilter = filter as CategoricalFilter;\r\n                    categoricalFilter.appliedValues.forEach(function(value) {\r\n                        filterValues += value.formattedValue + ', ';\r\n                    });\r\n                    break;\r\n                case tableau.FilterType.Range:\r\n                    // A range filter can have a min and/or a max.\r\n                    const rangeFilter = filter as RangeFilter;\r\n                    if (rangeFilter.minValue) {\r\n                        filterValues += 'min: ' + rangeFilter.minValue.formattedValue + ', ';\r\n                    }\r\n\r\n                    if (rangeFilter.maxValue) {\r\n                        filterValues += 'min: ' + rangeFilter.maxValue.formattedValue + ', ';\r\n                    }\r\n                    break;\r\n                case tableau.FilterType.RelativeDate:\r\n                    const relDateFilter = filter as RelativeDateFilter;\r\n                    filterValues += 'Period: ' + relDateFilter.periodType + ', ';\r\n                    filterValues += 'RangeN: ' + relDateFilter.rangeN + ', ';\r\n                    filterValues += 'Range Type: ' + relDateFilter.rangeType + ', ';\r\n                    break;\r\n                default:\r\n            }\r\n\r\n            // Cut off the trailing \", \"\r\n            return filterValues.slice(0, -2);\r\n        }\r\n\r\n        // This function removes all filters from a dashboard.\r\n        private clearAllFilters() {\r\n            // While performing async task, show loading message to user.\r\n            this._$('#loading').removeClass('hidden').addClass('show');\r\n            this._$('#filtersTable').removeClass('show').addClass('hidden');\r\n\r\n            const dashboard = tableau.extensions.dashboardContent.dashboard;\r\n\r\n            dashboard.worksheets.forEach(function(worksheet) {\r\n                worksheet.getFiltersAsync().then(async (filtersForWorksheet) => {\r\n                    const filterClearPromises = [];\r\n\r\n                    filtersForWorksheet.forEach(function(filter) {\r\n                        filterClearPromises.push(worksheet.clearFilterAsync(filter.fieldName));\r\n                    });\r\n\r\n                    // Same pattern as in fetchFilters, wait until all promises have finished\r\n                    // before updating the UI state.\r\n                    await Promise.allSettled(filterClearPromises);\r\n                    this.updateUIState(false);\r\n                });\r\n            }, this);\r\n        }\r\n\r\n        // This helper updates the UI depending on whether or not there are filters\r\n        // that exist in the dashboard.  Accepts a boolean.\r\n        private updateUIState(filtersExist: boolean) {\r\n            this._$('#loading').addClass('hidden');\r\n            if (filtersExist) {\r\n                this._$('#filtersTable').removeClass('hidden').addClass('show');\r\n                this._$('#noFiltersWarning').removeClass('show').addClass('hidden');\r\n            } else {\r\n                this._$('#noFiltersWarning').removeClass('hidden').addClass('show');\r\n                this._$('#filtersTable').removeClass('show').addClass('hidden');\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    console.log('Initializing Filtering extension.');\r\n    await new Filtering($).initialize();\r\n})();\r\n"],"names":[],"sourceRoot":""}